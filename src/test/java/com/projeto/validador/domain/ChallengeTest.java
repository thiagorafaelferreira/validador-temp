package com.projeto.validador.domain;

import lombok.Data;
import org.junit.jupiter.api.Test;

import java.util.*;
import java.util.stream.*;

/**
 * 1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, …
 *
 * The first term is "1"
 * Second term is "11", generated by reading first term as "One 1"
 * (There is one 1 in previous term)
 * Third term is "21", generated by reading second term as "Two 1"
 * Fourth term is "1211", generated by reading third term as "One 2 One 1"
 * and so on
 *
 * How to find n’th term?
 *
 * Example:
 *
 * Input: n = 3
 * Output: 21
 * Input: n = 5
 * Output: 111221
 */
public class ChallengeTest {

    private static final Map<Integer, String> NUMBER_TO_NAME = Map.of(
        1, "One", 2, "Two", 3, "Three", 4, "Four", 5, "Five",
        6, "Six", 7, "Seven", 8, "Eight", 9, "Nine"
    );

    private static final Map<String, String> NAME_TO_NUMBER = Map.of(
        "One", "1", "Two", "2", "Three", "3", "Four", "4", "Five", "5",
        "Six", "6", "Seven", "7", "Eight", "8", "Nine", "9"
    );

    private static String timesToName(int number) {
        return NUMBER_TO_NAME.getOrDefault(number, "Unknown");
    }

    private static String nameToNumber(String name) {
        return NAME_TO_NUMBER.getOrDefault(name, "0");
    }

    @Data
    static class NumberCounter {
        private Integer number;
        private Integer count;
    }

    @Test
    void challenge_generation_test() {
        int n = 5; // Generate 5 elements of the sequence
        String result = generateSequence(n);
        System.out.println("Generated sequence: " + result);
    }

    private String generateSequence(int n) {
        return Stream.iterate("1", this::nextNumber)
                   .limit(n)
                   .peek(System.out::println)
                   .reduce((first, second) -> second)
                   .orElse("1");
    }

    private String nextNumber(String s) {
        if (s.length() == 0) return "1";
        
        StringBuilder result = new StringBuilder();
        int count = 1;
        char current = s.charAt(0);
        
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == current) {
                count++;
            } else {
                result.append(convertCount(count)).append(current);
                current = s.charAt(i);
                count = 1;
            }
        }
        result.append(convertCount(count)).append(current);
        
        return result.toString();
    }
    
    private String convertCount(int count) {
        return (count > 1) ? nameToNumber(timesToName(count)) : "";
    }
}
